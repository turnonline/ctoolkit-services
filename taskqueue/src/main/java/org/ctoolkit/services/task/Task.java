/*
 * Copyright (c) 2017 Comvai, s.r.o. All Rights Reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

package org.ctoolkit.services.task;

import com.google.appengine.api.taskqueue.DeferredTask;
import com.google.appengine.api.taskqueue.Queue;
import com.google.appengine.api.taskqueue.TaskOptions;
import com.google.inject.Injector;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import java.util.Objects;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * The task, a standalone job definition to be executed asynchronously. Task represents a small, discrete unit of work.
 * <p>
 * Vocabulary:
 * <lo>
 * <li>Entity ID: an entity ID, represents an unique identification of the job</li>
 * <li>Task Name: an unique name of the job, composition of the Entity ID and name prefix.
 * If Entity ID is not defined, task name will be auto generated by the engine.</li>
 * <li>Queue name: a queue defined by the execution environment where task will be placed in.</li>
 * </lo>
 * <p>
 * Note: Queue, and task names must be a combination of one or more digits, letters a-z, underscores, and/or dashes,
 * satisfying the following regular expression:
 * [0-9a-zA-Z\-\_]+
 *
 * @author <a href="mailto:aurel.medvegy@ctoolkit.org>Aurel Medvegy</a>"
 * @see TaskExecutor
 */
public abstract class Task
        implements DeferredTask
{
    private static final long serialVersionUID = 1L;

    @Inject
    private static Injector injector;

    @Inject
    private transient TaskExecutor executor;

    private Long entityId;

    private String namePrefix;

    private Task next;

    private String queueName;

    private TaskOptions options;

    private Integer postponeFor;

    /**
     * Creates a task with an auto generated task name and will be added to the default queue.
     */
    public Task()
    {
        this.queueName = Queue.DEFAULT_QUEUE;
    }

    /**
     * Creates task with given name prefix and 'default' queue.
     *
     * @param namePrefix the name prefix
     */
    public Task( @Nonnull String namePrefix )
    {
        this();
        this.namePrefix = checkNotNull( namePrefix );
    }

    /**
     * Creates task with specified name prefix and queue names.
     *
     * @param namePrefix the name prefix
     * @param queueName  the queue name where task will be added.
     */
    public Task( @Nonnull String namePrefix, @Nonnull String queueName )
    {
        this.namePrefix = checkNotNull( namePrefix );
        this.queueName = checkNotNull( queueName );
    }

    /**
     * Returns the entity Id, represents an unique identification of the job.
     *
     * @return the entity Id
     */
    public Long getEntityId()
    {
        return entityId;
    }

    /**
     * Sets the entity Id.
     *
     * @param entityId the entity Id to be set
     */
    public void setEntityId( Long entityId )
    {
        this.entityId = entityId;
    }

    /**
     * Returns the task name as a composition of the non null Entity ID and name prefix.
     * Otherwise returns {@code null}.
     *
     * @return the task name, or {@code null} to be auto generated
     */
    public String getTaskName()
    {
        if ( namePrefix != null && entityId != null )
        {
            return namePrefix + "_" + entityId;
        }

        return null;
    }

    /**
     * Returns the queue name where task will be added.
     *
     * @return the queue name
     */
    public String getQueueName()
    {
        return queueName;
    }

    /**
     * Schedules the given task as the next one to execute once the this (parent) task has been successfully finished.
     * The parent task is the first one to be executed.
     *
     * @param task the task as the next one to execute
     * @return just added task to chain calls
     */
    public Task addNext( @Nonnull Task task )
    {
        return addNext( task, null );
    }

    /**
     * Schedules the given task as the next one to execute once the this (parent) task has been successfully finished.
     * The parent task is the first one to be executed.
     *
     * @param task        the task as the next one to execute
     * @param postponeFor the number of seconds to be added to current time for this,
     *                    that's a time when the task will be started. Max 30 days.
     * @return just added task to chain calls
     */
    public Task addNext( @Nonnull Task task, int postponeFor )
    {
        this.next = checkNotNull( task );
        return task.postponeFor( postponeFor );
    }

    /**
     * Schedules the given task as the next one to execute once the this (parent) task has been successfully finished.
     * The parent task is the first one to be executed.
     *
     * @param task    the task as the next one to execute
     * @param options the task configuration
     * @return just added task to chain calls
     */
    public Task addNext( @Nonnull Task task, @Nullable TaskOptions options )
    {
        this.next = checkNotNull( task );
        return task.options( options );
    }

    /**
     * Returns the configuration options of this task.
     *
     * @return the task options configuration, {@code null} if not set
     */
    public TaskOptions getOptions()
    {
        return options;
    }

    /**
     * Sets the configuration options for this task.
     *
     * @param options the configuration options instance
     * @return the same task to chain configuration
     */
    public Task options( @Nullable TaskOptions options )
    {
        this.options = options;
        return this;
    }

    /**
     * Returns the countdown of this task in seconds, the value to be used when task will be added to the queue.
     * If not defined, the task will be executed at some time in near future.
     *
     * @return the countdown in seconds, {@code null} if not set
     */
    public Integer getPostponeFor()
    {
        return postponeFor;
    }

    /**
     * Sets the countdown of this task in seconds.
     *
     * @param countdown the countdown to be set in seconds
     * @return the same task to chain configuration
     */
    public Task postponeFor( @Nullable Integer countdown )
    {
        this.postponeFor = countdown;
        return this;
    }

    @Override
    public boolean equals( Object o )
    {
        if ( this == o ) return true;
        if ( !( o instanceof Task ) ) return false;
        Task task = ( Task ) o;
        return Objects.equals( entityId, task.entityId ) &&
                Objects.equals( namePrefix, task.namePrefix ) &&
                Objects.equals( queueName, task.queueName );
    }

    @Override
    public int hashCode()
    {
        return Objects.hash( entityId, namePrefix, queueName );
    }

    @Override
    public String toString()
    {
        return "Task{" +
                "entityId=" + entityId +
                ", namePrefix='" + namePrefix + '\'' +
                ", next=" + ( next != null ) +
                ", queueName='" + queueName + '\'' +
                ", postponeFor=" + postponeFor +
                '}';
    }

    @Override
    public final void run()
    {
        injector.injectMembers( this );

        execute();

        // once parent task has been successfully executed, enqueue the next task
        if ( next != null )
        {
            TaskOptions nextTaskOptions = next.getOptions();
            if ( nextTaskOptions == null )
            {
                executor.schedule( next );
            }
            else
            {
                executor.schedule( next, nextTaskOptions );
            }
        }
    }

    /**
     * A method implementation to be executed asynchronously.
     */
    public abstract void execute();
}
